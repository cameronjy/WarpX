/* Copyright 2019-2020 Andrew Myers, Axel Huebl, Cameron Yang,
 * Maxence Thevenet, Weiqun Zhang
 *
 * This file is part of WarpX.
 *
 * License: BSD-3-Clause-LBNL
 */
#ifndef INJECTOR_MOMENTUM_H_
#define INJECTOR_MOMENTUM_H_

#include "CustomMomentumProb.H"
#include "Parser/GpuParser.H"
#include "Utils/WarpXConst.H"

#include <AMReX_Gpu.H>
#include <AMReX_Dim3.H>

// struct whose getMomentum returns constant momentum.
struct InjectorMomentumConstant
{
    InjectorMomentumConstant (amrex::Real a_ux, amrex::Real a_uy, amrex::Real a_uz) noexcept
        : m_ux(a_ux), m_uy(a_uy), m_uz(a_uz) {}

    AMREX_GPU_HOST_DEVICE
    amrex::XDim3
    getMomentum (amrex::Real, amrex::Real, amrex::Real,
                 amrex::RandomEngine const&) const noexcept
    {
        return amrex::XDim3{m_ux,m_uy,m_uz};
    }

    AMREX_GPU_HOST_DEVICE
    amrex::XDim3
    getBulkMomentum (amrex::Real, amrex::Real, amrex::Real) const noexcept
    {
        return amrex::XDim3{m_ux,m_uy,m_uz};
    }

private:
    amrex::Real m_ux, m_uy, m_uz;
};

// struct whose getMomentum returns momentum for 1 particle, from random
// gaussian distribution.
struct InjectorMomentumGaussian
{
    InjectorMomentumGaussian (amrex::Real a_ux_m, amrex::Real a_uy_m,
                              amrex::Real a_uz_m, amrex::Real a_ux_th,
                              amrex::Real a_uy_th, amrex::Real a_uz_th) noexcept
        : m_ux_m(a_ux_m), m_uy_m(a_uy_m), m_uz_m(a_uz_m),
          m_ux_th(a_ux_th), m_uy_th(a_uy_th), m_uz_th(a_uz_th)
        {}

    AMREX_GPU_HOST_DEVICE
    amrex::XDim3
    getMomentum (amrex::Real /*x*/, amrex::Real /*y*/, amrex::Real /*z*/,
                 amrex::RandomEngine const& engine) const noexcept
    {
        return amrex::XDim3{amrex::RandomNormal(m_ux_m, m_ux_th, engine),
                            amrex::RandomNormal(m_uy_m, m_uy_th, engine),
                            amrex::RandomNormal(m_uz_m, m_uz_th, engine)};
    }

    AMREX_GPU_HOST_DEVICE
    amrex::XDim3
    getBulkMomentum (amrex::Real /*x*/, amrex::Real /*y*/, amrex::Real /*z*/) const noexcept
    {
        return amrex::XDim3{m_ux_m, m_uy_m, m_uz_m};
    }

private:
    amrex::Real m_ux_m, m_uy_m, m_uz_m;
    amrex::Real m_ux_th, m_uy_th, m_uz_th;
};

// struct whose getMomentum returns momentum for 1 particle with relativistc
// drift velocity beta, from the Maxwell-Boltzmann distribution. Method is from
// Zenitani 2015 (Phys. Plasmas 22, 042116).
struct InjectorMomentumBoltzmann
{
    // Constructor whose inputs are:
    // the temperature parameter theta,
    // boost velocity/c beta,
    // and boost direction dir respectively.
    InjectorMomentumBoltzmann(amrex::Real s, amrex::Real l, amrex::Real b, amrex::Real n, amrex::Real de ,amrex::Real z, amrex::Real c, int di, bool cc) noexcept
        : sigma(s), lambdae(l), beta0(b), nbnd(n), delta(de), zcs(z), cellSize(c), dir(di), cellCentered(cc)
        {}

    AMREX_GPU_HOST_DEVICE
    amrex::XDim3
    getMomentum (amrex::Real /*x*/, amrex::Real /*y*/, amrex::Real /*z*/,
                 amrex::RandomEngine const& engine) const noexcept
    {
<<<<<<< HEAD
        // Sobol method for sampling MJ Speeds,
        // from Zenitani 2015 (Phys. Plasmas 22, 042116).
        amrex::Real z1, z2, gamma, theta, beta;
	amrex::Real vave;
        amrex::Real u [3];
	if(cellCentered)
	{
	    // z1 = (std::floor(z*1/cellSize)+0.5)*cellSize;
	    z1 = (std::trunc(z*1/cellSize+0.5*z/std::abs(z)))*cellSize;
	}
	else
	{
	    z1 = z;
	}
	beta = -1 * beta0 * (std::pow(std::cosh( (z1 + zcs) / delta ),-1) - std::pow(std::cosh( (z1 - zcs) / delta ),-1));
	// theta = sigma/4. * ( 51./50. - std::pow( -1. - std::tanh((z1 - zcs) / delta) + std::tanh((z1 + zcs) / delta) , 2 ) ) /
	//     ( ( 1. + 4.*( std::pow( std::cosh((z1 + zcs) / delta), -1 )  + std::pow( std::cosh((z1 - zcs) / delta), -1 ) ) ) *
	//       std::pow( 1. - std::pow(beta0 * (std::pow(std::cosh( (z1 + zcs) / delta ), -1 ) - std::pow(std::cosh( (z1 - zcs) / delta ), -1 ) ), 2 ), 0.5 ) );
	theta = sigma/4. * (51./50.
			    - std::pow( - ( 2./(M_PI/2.+5.-1.) ) * (std::atan(std::tanh((z1+zcs)/2./delta)) - std::atan(std::tanh((z1-zcs)/2./delta)) - M_PI/4.
								+ (5. - 1.) / 2. * (std::tanh((z1+zcs)/delta) - std::tanh((z1-zcs)/delta) - 1.)) , 2 ))
	    /( ( 1. + 4.*( std::pow( std::cosh((z1 + zcs) / delta), -1 )  + std::pow( std::cosh((z1 - zcs) / delta), -1 ) ) ) *
	       std::pow( 1. - std::pow(beta0 * (std::pow(std::cosh( (z1 + zcs) / delta ), -1 ) - std::pow(std::cosh( (z1 - zcs) / delta ), -1 ) ), 2), 0.5 ) );

	// theta = sigma/200;

	vave = std::sqrt(2.*theta);

	z1 = amrex::Random();
        z2 = amrex::Random();
        // Each value of sqrt(-log(z1))*sin(2*pi*z2) is a sample from a Boltzmann
        // distribution with sigma = average velocity / c
        // using the Box-Mueller Method.
        u[(dir+1)%3] = vave*std::sqrt(-std::log(z1)) *std::sin(2*M_PI*z2); 
        u[(dir+2)%3] = vave*std::sqrt(-std::log(z1)) *std::cos(2*M_PI*z2);
        u[dir] = vave*std::sqrt(-std::log(amrex::Random()))*
             std::sin(2*M_PI*amrex::Random());
	// u[(dir+1)%3] = 0;
        // u[(dir+2)%3] = 0;
	// u[dir] = 0;
        gamma = std::pow(u[0],2)+std::pow(u[1],2)+std::pow(u[2],2);
        gamma = std::sqrt(1+gamma);
        // The following condition is equtaion 32 in Zenitani 2015
        // (Phys. Plasmas 22, 042116) , called the flipping method. It
        // transforms the intergral: d3x' -> d3x  where d3x' is the volume
        // element for positions in the boosted frame. The particle positions
        // and densities can be initialized in the simulation frame.
        // The flipping method can transform any symmetric distribution from one
        // reference frame to another moving at a relative velocity of beta.
        // An equivalent alternative to this method native to WarpX would be to
        // initialize the particle positions and densities in the frame moving
        // at speed beta, and then perform a Lorentz transform on the positions
        // and MB sampled velocities to the simulation frame.
        z1 = amrex::Random();
        if(-beta*u[dir]/gamma > z1)
        {
          u[dir] = -u[dir];
        }
        // This Lorentz transform is equation 17 in Zenitani.
        // It transforms the integral d3u' -> d3u
        // where d3u' is the volume element for momentum in the boosted frame.
	// beta = beta0;
        u[dir] = 1/std::sqrt(1-pow(beta,2))*(u[dir]+gamma*beta);
        // Note that if beta = 0 then the flipping method and Lorentz transform
        // have no effect on the u[dir] direction.
	
        return amrex::XDim3 {u[0],u[1],u[2]};
    }

    AMREX_GPU_HOST_DEVICE
    amrex::XDim3
    getBulkMomentum (amrex::Real /*x*/, amrex::Real /*y*/, amrex::Real /*z*/) const noexcept
    {
        using namespace amrex;
        Real u[3];
        for (int idim = 0; idim < 3; ++idim) u[idim] = 0.0_rt;
        const Real gamma = 1./sqrt(1+beta0*beta0);
        u[dir] = gamma*beta0;
        return XDim3 {u[0],u[1],u[2]};
    }

private:
    int dir;
    bool cellCentered;
    amrex::Real sigma, lambdae, beta0, nbnd, zcs, cellSize, delta;
};

// struct whose getMomentum returns momentum for 1 particle with relativistc
// drift velocity beta, from the Maxwell-Juttner distribution. Method is from
// Zenitani 2015 (Phys. Plasmas 22, 042116).
struct InjectorMomentumJuttner
{
    // Constructor whose inputs are:
    // the temperature parameter theta,
    // boost velocity/c beta,
    // and boost direction dir respectively.
    InjectorMomentumJuttner(amrex::Real s, amrex::Real l, amrex::Real b, amrex::Real n, amrex::Real de, amrex::Real z, amrex::Real c, int di, bool cc) noexcept
        : sigma(s), lambdae(l), beta0(b), nbnd(n), delta(de), zcs(z), cellSize(c), dir(di), cellCentered(cc)
        {}

    AMREX_GPU_HOST_DEVICE
    amrex::XDim3
    getMomentum (amrex::Real /*x*/, amrex::Real /*y*/, amrex::Real /*z*/,
                 amrex::RandomEngine const& engine) const noexcept
    {
        // Sobol method for sampling MJ Speeds,
        // from Zenitani 2015 (Phys. Plasmas 22, 042116).
        amrex::Real z1, z2, gamma, theta, beta, A, B, C;
        amrex::Real u [3];
	if(cellCentered)
	{
	    // x1 = (std::floor(x*1/cellSize)+0.5)*cellSize;
	    z1 = (std::trunc(z*1/cellSize+0.5*z/std::abs(z)))*cellSize;
	}
	else
	{
	    z1 = z;
	}
	beta = -1 * beta0 * (std::pow(std::cosh( (z1 + zcs) / delta ),-1) - std::pow(std::cosh( (z1 - zcs) / delta ),-1));
	theta = sigma/4. * (51./50.
			    - std::pow( - ( 2./(M_PI/2.+5.-1.) ) * (std::atan(std::tanh((z1+zcs)/2./delta)) - std::atan(std::tanh((z1-zcs)/2./delta)) - M_PI/4.
								+ (5. - 1.) / 2. * (std::tanh((z1+zcs)/delta) - std::tanh((z1-zcs)/delta) - 1.)) , 2 ))
	    /( ( 1. + 4.*( std::pow( std::cosh((z1 + zcs) / delta), -1 )  + std::pow( std::cosh((z1 - zcs) / delta), -1 ) ) )
	       * std::pow( 1. - std::pow(beta0 * (std::pow(std::cosh( (z1 + zcs) / delta ), -1 ) - std::pow(std::cosh( (z1 - zcs) / delta ), -1 ) ), 2), 0.5 )
		);
        z1 = 0.;
        gamma = 0.;
        u[dir] = 0.;
        // This condition is equation 10 in Zenitani,
        // though z1 is defined differently.

        while(u[dir]-gamma <= z1)
        {
            u[dir] = -theta*
<<<<<<< HEAD
                std::log(amrex::Random()*amrex::Random()*amrex::Random());
            gamma = std::sqrt(1.0+std::pow(u[dir],2));
            z1 = theta*std::log(amrex::Random());
        }
        // The following code samples a random unit vector
        // and multiplies the result by speed u[dir].
        z1 = amrex::Random();
        z2 = amrex::Random();
	B = 2.0 * z1 - 1.0;
	A = std::sqrt(1.0-B*B);
	C = z2 * 2.0 * M_PI;
        // Direction dir is an input parameter that sets the boost direction:
        // 'x' -> d = 0, 'y' -> d = 1, 'z' -> d = 2.
        u[(dir+1)%3] = u[dir]*A*std::sin(C);
	u[(dir+2)%3] = u[dir]*A*std::cos(C);
        // The value of dir is the boost direction to be transformed.
        u[dir] = u[dir]*B;	
	// u[(dir+1)%3] = 0;
	// u[(dir+2)%3] = 0;
	// u[dir] = 0;
        z1 = amrex::Random();
        // The following condition is equtaion 32 in Zenitani, called
        // The flipping method. It transforms the intergral: d3x' -> d3x
        // where d3x' is the volume element for positions in the boosted frame.
        // The particle positions and densities can be initialized in the
        // simulation frame with this method.
        // The flipping method can similarly transform any
        // symmetric distribution from one reference frame to another moving at
        // a relative velocity of beta.
        // An equivalent alternative to this method native to WarpX
        // would be to initialize the particle positions and densities in the
        // frame moving at speed beta, and then perform a Lorentz transform
        // on their positions and MJ sampled velocities to the simulation frame.
        if(-beta*u[dir]/gamma>z1)
        {
            u[dir] = -u[dir];
        }
        // This Lorentz transform is equation 17 in Zenitani.
        // It transforms the integral d3u' -> d3u
        // where d3u' is the volume element for momentum in the boosted frame.
	// beta = theta;
        u[dir] = 1/std::sqrt(1-pow(beta,2))*(u[dir]+gamma*beta);
        // Note that if beta = 0 then the flipping method and Lorentz transform
        // have no effect on the u[dir] direction.
        return amrex::XDim3 {u[0],u[1],u[2]};
    }

    AMREX_GPU_HOST_DEVICE
    amrex::XDim3
    getBulkMomentum (amrex::Real /*x*/, amrex::Real /*y*/, amrex::Real /*z*/) const noexcept
    {
        using namespace amrex;
        Real u[3];
        for (int idim = 0; idim < 3; ++idim) u[idim] = 0.0_rt;
        const Real gamma = 1./sqrt(1+beta0*beta0);
        u[dir] = gamma*beta0;
        return XDim3 {u[0],u[1],u[2]};
    }

private:
    int dir;
    bool cellCentered;
    amrex::Real sigma, lambdae, beta0, nbnd, zcs, cellSize, delta;
};

/**
 * \brief struct whose getMomentum returns momentum for 1 particle, for
 * radial expansion.
 *
 * Note - u_over_r is expected to be the normalized momentum gamma*beta
 * divided by the physical position in SI units.
**/
struct InjectorMomentumRadialExpansion
{
    InjectorMomentumRadialExpansion (amrex::Real a_u_over_r) noexcept
        : u_over_r(a_u_over_r)
        {}

    AMREX_GPU_HOST_DEVICE
    amrex::XDim3
    getMomentum (amrex::Real x, amrex::Real y, amrex::Real z,
                 amrex::RandomEngine const&) const noexcept
    {
        return {x*u_over_r, y*u_over_r, z*u_over_r};
    }

    AMREX_GPU_HOST_DEVICE
    amrex::XDim3
    getBulkMomentum (amrex::Real x, amrex::Real y, amrex::Real z) const noexcept
    {
        return {x*u_over_r, y*u_over_r, z*u_over_r};
    }

private:
    amrex::Real u_over_r;
};

// struct whose getMomentumm returns local momentum computed from parser.
struct InjectorMomentumParser
{
    InjectorMomentumParser (WarpXParser const& a_ux_parser,
                            WarpXParser const& a_uy_parser,
                            WarpXParser const& a_uz_parser) noexcept
        : m_ux_parser(a_ux_parser), m_uy_parser(a_uy_parser),
          m_uz_parser(a_uz_parser) {}

    AMREX_GPU_HOST_DEVICE
    amrex::XDim3
    getMomentum (amrex::Real x, amrex::Real y, amrex::Real z,
                 amrex::RandomEngine const&) const noexcept
    {
        return amrex::XDim3{m_ux_parser(x,y,z),m_uy_parser(x,y,z),m_uz_parser(x,y,z)};
    }

    AMREX_GPU_HOST_DEVICE
    amrex::XDim3
    getBulkMomentum (amrex::Real x, amrex::Real y, amrex::Real z) const noexcept
    {
        return amrex::XDim3{m_ux_parser(x,y,z),m_uy_parser(x,y,z),m_uz_parser(x,y,z)};
    }

    GpuParser<3> m_ux_parser, m_uy_parser, m_uz_parser;
};

// Base struct for momentum injector.
// InjectorMomentum contains a union (called Object) that holds any one
// instance of:
// - InjectorMomentumConstant       : to generate constant density;
// - InjectorMomentumBoltzmann       : to generate gaussian distribution;
// - InjectorMomentumRadialExpansion: to generate radial expansion;
// - InjectorMomentumParser         : to generate momentum from parser;
// The choice is made at runtime, depending in the constructor called.
// This mimics virtual functions.
struct InjectorMomentum
{
    // This constructor stores a InjectorMomentumConstant in union object.
    InjectorMomentum (InjectorMomentumConstant* t,
                      amrex::Real a_ux, amrex::Real a_uy, amrex::Real a_uz)
        : type(Type::constant),
          object(t, a_ux, a_uy, a_uz)
    { }

    // This constructor stores a InjectorMomentumParser in union object.
    InjectorMomentum (InjectorMomentumParser* t,
                      WarpXParser const& a_ux_parser,
                      WarpXParser const& a_uy_parser,
                      WarpXParser const& a_uz_parser)
        : type(Type::parser),
          object(t, a_ux_parser, a_uy_parser, a_uz_parser)
    { }
    
    // This constructor stores a InjectorMomentumGaussian in union object.
    InjectorMomentum (InjectorMomentumGaussian* t,
                      amrex::Real a_ux_m, amrex::Real a_uy_m, amrex::Real a_uz_m,
                      amrex::Real a_ux_th, amrex::Real a_uy_th, amrex::Real a_uz_th)
        : type(Type::gaussian),
          object(t,a_ux_m,a_uy_m,a_uz_m,a_ux_th,a_uy_th,a_uz_th)
    { }

    InjectorMomentum (InjectorMomentumBoltzmann* t,
		      amrex::Real s, amrex::Real l, amrex::Real b, amrex::Real n, amrex::Real de, amrex::Real x, amrex::Real c, int di, bool cc)
	: type(Type::boltzmann),
	  object(t, s, l, b, n, de, x, c, di, cc)
    { }

     // This constructor stores a InjectorMomentumJuttner in union object.
     InjectorMomentum (InjectorMomentumJuttner* t,
                       amrex::Real s, amrex::Real l, amrex::Real b, amrex::Real n, amrex::Real de, amrex::Real x, amrex::Real c, int di, bool cc)
         : type(Type::juttner),
           object(t, s, l, b, n, de, x, c, di, cc)
    { }

    // This constructor stores a InjectorMomentumCustom in union object.
    InjectorMomentum (InjectorMomentumCustom* t,
                      std::string const& a_species_name)
        : type(Type::custom),
          object(t, a_species_name)
    { }

    // This constructor stores a InjectorMomentumRadialExpansion in union object.
    InjectorMomentum (InjectorMomentumRadialExpansion* t,
                      amrex::Real u_over_r)
        : type(Type::radial_expansion),
          object(t, u_over_r)
    { }

    // Explicitly prevent the compiler from generating copy constructors
    // and copy assignment operators.
    InjectorMomentum (InjectorMomentum const&) = delete;
    InjectorMomentum (InjectorMomentum&&) = delete;
    void operator= (InjectorMomentum const&) = delete;
    void operator= (InjectorMomentum &&) = delete;

    void clear ();

    // call getMomentum from the object stored in the union
    // (the union is called Object, and the instance is called object).
    AMREX_GPU_HOST_DEVICE
    amrex::XDim3
    getMomentum (amrex::Real x, amrex::Real y, amrex::Real z,
                 amrex::RandomEngine const& engine) const noexcept
    {
        switch (type)
        {
        case Type::parser:
        {
            return object.parser.getMomentum(x,y,z,engine);
        }
        case Type::gaussian:
        {
            return object.gaussian.getMomentum(x,y,z,engine);
        }
        case Type::boltzmann:
        {
            return object.boltzmann.getMomentum(x,y,z,engine);
        }
        case Type::juttner:
        {
            return object.juttner.getMomentum(x,y,z,engine);
        }
        case Type::constant:
        {
            return object.constant.getMomentum(x,y,z,engine);
        }
        case Type::radial_expansion:
        {
            return object.radial_expansion.getMomentum(x,y,z,engine);
        }
        case Type::custom:
        {
            return object.custom.getMomentum(x,y,z,engine);
        }
        default:
        {
            amrex::Abort("InjectorMomentum: unknown type");
            return {0.0,0.0,0.0};
        }
        }
    }

    // call getBulkMomentum from the object stored in the union
    // (the union is called Object, and the instance is called object).
    AMREX_GPU_HOST_DEVICE
    amrex::XDim3
    getBulkMomentum (amrex::Real x, amrex::Real y, amrex::Real z) const noexcept
    {
        switch (type)
        {
        case Type::parser:
        {
            return object.parser.getBulkMomentum(x,y,z);
        }
        case Type::gaussian:
        {
            return object.gaussian.getBulkMomentum(x,y,z);
        }
        case Type::boltzmann:
        {
            return object.boltzmann.getBulkMomentum(x,y,z);
        }
        case Type::juttner:
        {
            return object.juttner.getBulkMomentum(x,y,z);
        }
        case Type::constant:
        {
            return object.constant.getBulkMomentum(x,y,z);
        }
        case Type::radial_expansion:
        {
            return object.radial_expansion.getBulkMomentum(x,y,z);
        }
        case Type::custom:
        {
            return object.custom.getBulkMomentum(x,y,z);
        }
        default:
        {
            amrex::Abort("InjectorMomentum: unknown type");
            return {0.0,0.0,0.0};
        }
        }
    }

private:
    enum struct Type { constant, custom, gaussian, boltzmann, juttner, radial_expansion, parser};
    Type type;

    // An instance of union Object constructs and stores any one of
    // the objects declared (constant or custom or gaussian or
    // radial_expansion or parser).
    union Object {
        Object (InjectorMomentumConstant*,
                amrex::Real a_ux, amrex::Real a_uy, amrex::Real a_uz) noexcept
            : constant(a_ux,a_uy,a_uz) {}
        Object (InjectorMomentumCustom*,
                std::string const& a_species_name) noexcept
            : custom(a_species_name) {}
        Object (InjectorMomentumGaussian*,
                amrex::Real a_ux_m, amrex::Real a_uy_m,
                amrex::Real a_uz_m, amrex::Real a_ux_th,
                amrex::Real a_uy_th, amrex::Real a_uz_th) noexcept
            : gaussian(a_ux_m,a_uy_m,a_uz_m,a_ux_th,a_uy_th,a_uz_th) {}
        Object (InjectorMomentumBoltzmann*,
                amrex::Real s, amrex::Real l, amrex::Real b, amrex::Real n, amrex::Real de, amrex::Real x, amrex::Real c, int di, bool cc) noexcept
            : boltzmann(s, l, b, n, de, x, c, di, cc) {}
        Object (InjectorMomentumJuttner*,
                amrex::Real s, amrex::Real l, amrex::Real b, amrex::Real n, amrex::Real de, amrex::Real x, amrex::Real c, int di, bool cc) noexcept
            : juttner(s, l, b, n, de, x, c, di, cc) {}
        Object (InjectorMomentumRadialExpansion*,
                amrex::Real u_over_r) noexcept
            : radial_expansion(u_over_r) {}
        Object (InjectorMomentumParser*,
                WarpXParser const& a_ux_parser,
                WarpXParser const& a_uy_parser,
                WarpXParser const& a_uz_parser) noexcept
            : parser(a_ux_parser, a_uy_parser, a_uz_parser) {}
        InjectorMomentumConstant constant;
        InjectorMomentumCustom   custom;
        InjectorMomentumGaussian gaussian;
        InjectorMomentumBoltzmann boltzmann;
        InjectorMomentumJuttner juttner;
        InjectorMomentumRadialExpansion radial_expansion;
        InjectorMomentumParser   parser;
    };
    Object object;
};

// In order for InjectorMomentum to be trivially copyable, its destructor
// must be trivial.  So we have to rely on a custom deleter for unique_ptr.
struct InjectorMomentumDeleter {
    void operator () (InjectorMomentum* p) const {
        if (p) {
            p->clear();
            delete p;
        }
    }
};

#endif
